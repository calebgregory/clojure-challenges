(ns challenges.core
  (:use [clojure.string :as str]))

(defn -main
  "I don't do a whole lot ... yet."
  [& args]
  (println "Hello, World!"))

;; If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23.
;; Find the sum of all the multiples of 3 or 5 below 1000.
(defn sum-of-multiples-of-3-5
  "Find sum of all multiples of 3 and 5 from 0 to 1000"
  []
  (reduce +
          (filter
           #(or
             (zero? (mod % 3))
             (zero? (mod % 5)))
           (range 1000))))

;; Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:
;; 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
;; By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.
(defn fib
  [a b]
  (cons a (lazy-seq (fib b (+ b a)))))

(defn sum-of-even-fib
  "Take sum of even fib numbers in range [0,4000000]"
  []
  (reduce +
          (filter even?
           (take 34 (fib 0 1)))))

;; The prime factors of 13195 are 5, 7, 13 and 29.
;; What is the largest prime factor of the number 600851475143 ?
(defn factors-of
  [x]
  (filter #(zero? (mod x %)) (range 1 x)))

(defn prime?
  [x]
  (= (last (factors-of x)) 1))

(defn prime-factors-of
  [x]
  (filter prime? (factors-of x)))

(defn greatest-prime-factor-of
  "Considering primes within one [n, n+1000] range at a time,
  see what primes the big-number is divisible by (= 0 (mod big-number prime)),
  then take new-big-number = big-number/prime,
  and find what primes _it_ is divisible by.
  Once it's iterated 10 times, just call it a day and return the highest of these."
  [x]
  (let [start 1000]
    (loop [iteration 1
           big-number x
           primes (filter prime? (range start))
           prime-factors []]
      (if (> iteration 10)
        (last prime-factors)
        (if-let
            [prime (first (filter #(zero? (mod big-number %)) primes))]
          (recur (inc iteration)
                 (/ big-number prime)
                 primes
                 (conj prime-factors prime))
          (recur (inc iteration)
                 big-number
                 (filter prime?
                         (range
                          (* iteration start)
                          (+ (* iteration start) start)))
                 prime-factors))))))

;; A palindromic number reads the same both ways.
;; The largest palindrome made from the product of two 2-digit numbers is
;; 9009 = 91 Ã— 99.

;; Find the largest palindrome made from the product of two 3-digit numbers.

(defn palindrome?
  [x]
  (=
   (clojure.string/reverse (str x))
   (str x)))

(def products-of-three-digit-nums
  (for [x (range 100 1000)
        y (range 100 1000)]
    (* x y)))

(def largest-palindrome-product
  (loop [largest 0
         largest? 0
         remaining products-of-three-digit-nums]
    (if (empty? remaining)
      largest
      (if (and (palindrome? largest?)
               (> largest? largest))
        (recur largest? (first remaining) (rest remaining))
        (recur largest (first remaining) (rest remaining))))))

(def largest-palindrome-product-2
  (apply max (filter palindrome? products-of-three-digit-nums)))

;; 2520 is the smallest number that can be divided by each of the
;; numbers from 1 to 10 without any remainder.

;; What is the smallest positive number that is evenly divisible
;; by all of the numbers from 1 to 20?

(defn divides?
  "This reads 'does x divide y?'"
  [x y]
  (= (mod y x) 0))

'(def smallest-evenly-divisible-1-to-20
  (let [divisors (range 1 20)] ; (= 20 (* 2 10))
    (loop [result 1
           remaining-divisors divisors]
      (let [[divisor & more] remaining-divisors]
        (if (divides? divisor result)
          (if (empty? more)
            result
            (recur result more))
          (recur (inc result) divisors))))))

;; Write a function which removes consecutive duplicates from a sequence.
;; e.g., "Leeeeeeeeeeroy" => "Leroy"

(defn compress-seq
  [coll]
  (loop [result []
         more coll]
    (if (empty? more)
      result
      (if (= (last result) (first more))
        (recur result (rest more))
        (recur (conj result (first more)) (rest more))))))

(defn compress-seq-2
  [xs]
  (map first (partition-by identity xs)))

;; Write a function which takes a variable number of parameters and returns
;; the maximum value.

(defn my-max
  [x & xs]
  (cond
   (nil? xs) x
   (> x (first xs)) (recur x (next xs))
   :else (recur (first xs) (next xs))))

(defn my-max-2
  [& args]
  (apply (comp last sort list) args))

(defn my-max-3
  [& xs]
  (reduce #(if (> %1 %2) %1 %2) xs))

(defn my-max-4
  [& xs]
  (-> xs sort last))

(defn my-interleave-b
  [c1 c2]
  (apply concat
         (map-indexed
          (fn [idx itm]
            (if-let [other-itm (nth c2 idx)]
              [itm other-itm]
              nil))
          c1)))

(defn my-interleave
  ([] '())
  ([c1 c2]
   (cons (first c1)
         (cons (first c2)
               (my-interleave (rest c1) (rest c2))))))

(defn exp
  [base pow]
  (apply * (repeat pow base)))

(defn is-power-of-4?
  [x]
  (loop [n x]
    (or (= 1 n)
        (if (zero? (mod n 4))
          (recur (/ n 4))
          false))))


; accum("abcd") --> "A-Bb-Ccc-Dddd"
; accum("RqaEzty") --> "R-Qq-Aaa-Eeee-Zzzzz-Tttttt-Yyyyyyy"
; accum("cwAt") --> "C-Ww-Aaa-Tttt"

(defn accum
  [str]
  (->> (map-indexed vector)
       (map #(repeat (inc (first %)) (second %)))
       (map str/join)
       (map str/capitalize)
       (str/join #"-")))

(defn accum1
  [str]
  (let [enum (map-indexed vector str)]
    (str/join \-
          (map (fn [[i c]]
                 (->>
                  c
                  (repeat (inc i))
                  str/join
                  str/capitalize))
               enum))))
